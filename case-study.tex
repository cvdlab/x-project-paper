\section{Case study}\label{sec:case-study}
In this section the design and the implementation of a blog platform is presented. 

For a blog platform the essential entities to model are: \texttt{Post} and \texttt{Tag}.

\begin{lstlisting}[language=json]
{
  "name": "Post",
  "properties": {
    "title": { "type": "string" },
    "posted": { "type": "date" },
    "content": { "type": "text" },
    "permalink": { "type": "string" }
  }, 
  "relations": {
    "tags": { "type": "has_many", "model": "Tag"}
  }
}
\end{lstlisting}

\begin{lstlisting}[language=json]
{
  "name": "Tag",
  "properties": {
    "name": { "type": "string" }
  }
}
\end{lstlisting}

These models results in the following HTTP RESTful API (automatically generated by Loopback server).

\begin{lstlisting}
GET|POST /api/Posts
GET|PUT|DELETE /api/Posts/:post_id
GET|POST /api/Tags
GET|PUT|DELETE /api/Tags/:tag_id
\end{lstlisting}

Since a snippet is worth a thousand words, in the following the code of the pages of the app is shown.
It is important to remark how easily a page can be built without writing code but assembling elements. 

\paragraph{Admin part}

Tha admin part is composed by two pages: \texttt{page-collection} and \texttt{page-model-edit}.
These pages are accessible via the following routes.

\begin{lstlisting}[language=HTML5]
<x-router>
  <x-route route="/admin/:collection" 
    page="page-collection" />
  <x-route route="/admin/:collection/:id"
    page="page-model-edit" />
</x-router>
\end{lstlisting}

Where:
the param \texttt{:collection} is the name of the collection to inspect;
the param \texttt{:id} is the id of the model to edit.
These params are set as attributes of the page element.

\vspace{0.2cm}

\texttt{<page-collection>} shows the models of a collection.

\begin{lstlisting}[language=HTML5]
<template name="page-collection">
  <api-collection-schema name="{collection}"
    schema="{schema}" />
  <api-collection-get 
    name="{collection}" where="{where}" 
    page="{page}" perpage="{perpage}"  
    items="{items}" count="{count}" />
  <api-collection-where schema="{schema}"
    where="{where}" />
  <x-table schema="{schema}" items="{items}" />
  <x-pager count="{count}" perpage="{perpage}"
    current="{page}" />
</template>
\end{lstlisting}

Where: 
the value \texttt{collection} is picked from the url, via the parameter \texttt{:collection};
the value \texttt{schema} is the output of \texttt{<api-collection-schema>} and the input of \texttt{<api-collection-get>} and \texttt{<x-table>};
the value \texttt{items} is the output of \texttt{<api-collection-get>} and the input of \texttt{<x-table>};
the value \texttt{where} is the output of \texttt{<api-collection-where>} and the input of \texttt{<api-collection-get>};
the value \texttt{count} is the output of \texttt{<api-collection-get>} and the input of \texttt{<x-pager>};
the values \texttt{perpage} and \texttt{page} are the outputs of \texttt{<x-pager>} and the inputs of \texttt{<api-collection-get>};
every time the user (the admin) interacts with the pagination (\texttt{<x-pager>}) or the advanced search options (\texttt{<api-collection-where>}), \texttt{<api-collection-get>} regenerates the request to get the list of models using pagination and query paramenters.

\vspace{0.2cm}

\texttt{<page-model-edit>} shows the forms to update a model.

\begin{lstlisting}[language=HTML5]
<template name="page-model-edit">
  <api-collection-schema name="{collection}"
    schema="{schema}" />
  <api-model-get name="{collection}" 
    model-id="{id}" model="{model}" />
  <x-form schema="{schema}" model="{model}" />
  <api-model-put  name="{collection}"
    model-id="{model_id}" model="{model}" />
</template>
\end{lstlisting}

Where: 
the value \texttt{schema} is the output of \texttt{<api-collection-schema>} and the input of \texttt{<x-form>};
the value \texttt{model} is the output of \texttt{<api-model-get>} and \texttt{<x-form>} and the input of \texttt{<api-model-put>}.

\paragraph{User part}

The user part is essentially composed by two pages: \texttt{page-posts} and \texttt{page-post}.

\begin{lstlisting}[language=HTML5]
<x-router>
  <x-route route="/" page="page-posts" />
  <x-route route="posts/:id" page="page-post" />
</x-router>
\end{lstlisting}

\texttt{<page-posts>} shows the list of posts.

\begin{lstlisting}[language=HTML5]
<template name="page-posts">
  <api-collection-get name="Posts"
    perpage="10" page="{page}" 
    items="{posts}" count="{count}" />
  <template is="dom-repeat" items="{posts}">
    <li>{item.title} {item.date}</li>
  </template>
  <x-pager perpage="10" total="{count}" 
    current="{page}" />
</template>
\end{lstlisting}

Where:
the value \texttt{posts} is the output of \texttt{api-collection-get} and the input of the \texttt{<template>} iterator; for each \texttt{item} in \texttt{posts}, a list item with the post info (\texttt{title} and publishing \texttt{date}) is printed.

\vspace{0.2cm}

\texttt{<page-post>} shows a post. 

\begin{lstlisting}[language=HTML5]
<template name="page-post">
  <api-model-get name="Posts" model-id="{id}" 
    model="{post}" />
  <h1>{post.title}</h1>
  <h2>by {post.author}</h2>
  <h3>on {post.date}</h3>
  <div>{post.content}</div>
</template>
\end{lstlisting}

Where: once \texttt{<api-model-get>} has fetched the \texttt{post} (identified by \texttt{id}),
\texttt{title}, \texttt{author}, \texttt{date} and \texttt{content} of the \texttt{post} will be shown.
